---
layout: default
title: Simple Microbenchmark
permalink: /simplemicrobenchmark/index.html
---


Lets assume we want to write and run a simple microbenchmark which tests the `map` method on the Scala `Range` class.
This section shows the basics of how to do this.


## Preparatory steps

ScalaMeter requires at least JRE 7 update 4 and Scala 2.10 to be run.

1. Make sure you have at least JRE 7 update 4 installed on your machine.<br/>
[Download](http://www.java.com) the latest version or update an existing one.

2. Make sure you have at least Scala 2.10 installed on your machine.<br/>
[Download](http://www.scala-lang.org/downloads) and install Scala 2.10 if you don't have a newer version.

3. Go to the [download](/home/download/) section and download the latest release of ScalaMeter.

4. Create a new project and a new file named `RangeMicrobenchmark.scala` in your editor.


## Implementing the microbenchmark

Start with the following `import` statement:

    import org.scalameter.api._

This gives us access to most of the ScalaMeter API.
Alternatively, we can import different parts of ScalaMeter selectively, but this will do for now.

A ScalaMeter represents performance tests with the `PerformanceTest` abstract class -- to implement a
performance test, we have to extend this class.
A performance test can either be a singleton `class` or a `object`.
The only difference from ScalaMeter's point of view is that `object` performance tests will have
a `main` method, hence being runnable applications.

For that reason, we choose the latter:

    object RangeBenchmark
    extends PerformanceTest.Microbenchmark {

The `PerformanceTest` abstract class is a highly configurable test template which allows more than
we need right now.
Instead of inheriting it directly, we inherit a predefined class called `PerformanceTest.Microbenchmark`
which is a performance test configured to simply run the tests and output them in the terminal.

Most benchmarks need input data that they are executed on.
To define input data in a clean and composable manner ScalaMeter supports data generators
represented by the `Gen` interface.
These generators are similar to the ones in frameworks like [ScalaCheck](https://github.com/rickynils/scalacheck/wiki/User-Guide)
in that they are composable with `for`-comprehensions and that they can generate multiple values.
However, ScalaMeter generators do not generate random or arbitrary values -- the values they produce
are always the same and well-defined.

ScalaCheck generators can be roughly divided into 2 groups -- *basic* and *composed* generators.
There exist a number of basic generators already defined for you.
One of them is called `Gen.range`, and it generates integers in a specified range.

    val sizes: Gen[Int] = Gen.range("size")(300000, 1500000, 300000)

This creates a generator which generates integers the range from `300000` to `1500000` in
steps of `300000`.
A basic generator must always be given a name -- we call our basic generator `size`, because
it will produce different sizes for our ranges.

Our microbenchmark will not be taking sizes as inputs -- instead, it will take different ranges.
For each of the different sizes generated by the above defined generator, we need one range.
We can express this elegantly using a `for`-comprehension:

    val ranges: Gen[Range] = for {
      size <- sizes
    } yield 0 until size

This `for`-comprehension says: For every `size` given by the `sizes` generator yield a range from `0`
to `size`.
It produces a new generator `ranges` of type `Gen[Range]`.
The new generator is a composed generator, because it has been obtain through a `for`-comprehension.

We're now done with defining input data for the benchmark, and we move on to defining the actual
code that the benchmark is supposed to evaluate.

<div class="imagenoframe">
  <img src="/resources/images/logo-yellow-small.png"></img>
</div>










